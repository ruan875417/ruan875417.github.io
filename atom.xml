<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ryan&#39;s notes</title>
  <subtitle>Fighting</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-08T15:37:35.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ryan Ruan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis源码剖析--简单动态字符串sds</title>
    <link href="http://yoursite.com/2018/03/08/redis/redis-sds/"/>
    <id>http://yoursite.com/2018/03/08/redis/redis-sds/</id>
    <published>2018-03-07T16:00:00.000Z</published>
    <updated>2018-03-08T15:37:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>redis没有使用c语言的字符串标识，而是自己构建了已个简单的动态字符串结构SDS，主要实现在sds.h和sds.c中。<a id="more"></a></p>
<h2 id="SDS定义"><a href="#SDS定义" class="headerlink" title="SDS定义"></a>SDS定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</div></pre></td></tr></table></figure>
<p>从上面的定义看，sds就是char*。与c语言一样，redis也是分配连续的一段内存来保存字符串，但与c语言字符串不同的是，redis的字符串是二进制安全的，它可以存储任意二进制数据，所以它不能以’\0’来标识字符串的结束，因此必定存在一个长度字段已获取整个字符串。长度字段见header定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></div><div class="line"> * However is here to document the layout of type 5 SDS strings. */</div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">// flags共8位，低三位保存类型标志，高5位保存字符串长度，字符串长度必须小于32(2^5-1)</span></div><div class="line">    <span class="keyword">char</span> buf[]; <span class="comment">// 保存具体的字符串</span></div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></div><div class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">// 字符串长度，不包含最后的空终止字符</span></div><div class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">// 字符串的最大容量，不包含header和最后的空终止字符</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">// 低三位保存类型标志</span></div><div class="line">    <span class="keyword">char</span> buf[]; <span class="comment">// 保存具体的字符串</span></div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></div><div class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">/* used */</span></div><div class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></div><div class="line">    <span class="keyword">char</span> buf[];</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></div><div class="line">    <span class="keyword">uint32_t</span> len; <span class="comment">/* used */</span></div><div class="line">    <span class="keyword">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></div><div class="line">    <span class="keyword">char</span> buf[];</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></div><div class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* used */</span></div><div class="line">    <span class="keyword">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></div><div class="line">    <span class="keyword">char</span> buf[];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>sds使用了5种header定义以节省内存，而sdshdr5永远不会被使用，其他4种header都有以下4个字段：</p>
<ul>
<li>len：字符串长度，不包含最后的空终止字符</li>
<li>alloc：字符串的最大容量，不包含header和最后的空终止字符</li>
<li>flags：header的类型</li>
<li>buf：保存具体的字符串</li>
</ul>
<p>5种header的flags取值如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_5  0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_8  1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_16 2</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_32 3</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_64 4</span></div></pre></td></tr></table></figure>
<p>这里需要注意的是<strong>attribute</strong> ((<strong><strong>packed</strong></strong>))，它的作用是告诉编译器取消结构在编译过程中的内存对齐,按照实际占用字节数进行分配。如果没有<strong>attribute</strong> ((<strong>packed</strong>)，就不能保证sds的header部分和数据部分是紧紧相邻的，不能按照固定偏移量获取flags字段。因此，redis的sds字符串的内存布局如下：</p>
<p><img src="/img/redis/sds/1.png" alt="sds memory layout"> </p>
<p>sds定义了以下几个宏来操作header：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_MASK 7 <span class="comment">// 类型掩码</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_BITS 3</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T))); <span class="comment">// 获取header头指针</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T)))) <span class="comment">// 获取header头指针</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_5_LEN(f) ((f)&gt;&gt;SDS_TYPE_BITS) <span class="comment">// 获取sdshdr5的len值</span></span></div></pre></td></tr></table></figure>
<p>这里要注意的是sdshdr##T表示将sdshdr和T连接成一个，如T为8，sdshdr##T即为sdshdr8。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;redis没有使用c语言的字符串标识，而是自己构建了已个简单的动态字符串结构SDS，主要实现在sds.h和sds.c中。
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码剖析--内存管理</title>
    <link href="http://yoursite.com/2018/03/05/redis/redis-memory-management/"/>
    <id>http://yoursite.com/2018/03/05/redis/redis-memory-management/</id>
    <published>2018-03-04T16:00:00.000Z</published>
    <updated>2018-03-08T14:04:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>redis使用c语言编写，而c语言没有垃圾回收机制，所有的内存分配和释放都要手动管理。redis在实现中封装c语言的malloc,calloc,realloc和free函数，加上一些异常处理和内存统计功能来对自己的内存进行管理，主要实现在zmalloc.h和zmalloc.c中。<a id="more"></a></p>
<h2 id="屏蔽底层平台的差异"><a href="#屏蔽底层平台的差异" class="headerlink" title="屏蔽底层平台的差异"></a>屏蔽底层平台的差异</h2><p>redis对系统的内存分配释放函数进行了一层简单的封装，屏蔽了底层平台的差异，同时方便自己实现相关的函数。src/zmalloc.h文件中的相关宏定义屏蔽了底层平台之间的差异，相关宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//是否使用tcmalloc，如果是，会用tcmalloc对应的函数替换掉标准的libc中的函数实现</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(USE_TCMALLOC)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ZMALLOC_LIB (<span class="meta-string">"tcmalloc-"</span> __xstr(TC_VERSION_MAJOR) <span class="meta-string">"."</span> __xstr(TC_VERSION_MINOR))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;google/tcmalloc.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> (TC_VERSION_MAJOR == 1 &amp;&amp; TC_VERSION_MINOR &gt;= 6) || (TC_VERSION_MAJOR &gt; 1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_MALLOC_SIZE 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> zmalloc_size(p) tc_malloc_size(p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">"Newer version of tcmalloc required"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="comment">//是否使用jemalloc，如果是，会用jemalloc对应的函数替换掉标准的libc中的函数实现</span></div><div class="line"><span class="comment">//jemalloc已经作为源码包的一部分包含在源码包deps/jemalloc目录下，可以直接被使用</span></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(USE_JEMALLOC)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ZMALLOC_LIB (<span class="meta-string">"jemalloc-"</span> __xstr(JEMALLOC_VERSION_MAJOR) <span class="meta-string">"."</span> __xstr(JEMALLOC_VERSION_MINOR) <span class="meta-string">"."</span> __xstr(JEMALLOC_VERSION_BUGFIX))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jemalloc/jemalloc.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> (JEMALLOC_VERSION_MAJOR == 2 &amp;&amp; JEMALLOC_VERSION_MINOR &gt;= 1) || (JEMALLOC_VERSION_MAJOR &gt; 2)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_MALLOC_SIZE 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> zmalloc_size(p) je_malloc_usable_size(p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">"Newer version of jemalloc required"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="comment">//当前系统是否是Mac系统，如果是，则使用&lt;malloc/malloc.h&gt;中的内存分配函数</span></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__APPLE__)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc/malloc.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_MALLOC_SIZE 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> zmalloc_size(p) malloc_size(p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="comment">//最后使用标准的libc中的内存管理函数</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ZMALLOC_LIB</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ZMALLOC_LIB <span class="meta-string">"libc"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFIX_SIZE (0)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__sun) || defined(__sparc) || defined(__sparc__)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFIX_SIZE (sizeof(long long))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFIX_SIZE (sizeof(size_t))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p>从上面的宏预处理，我们可以看出redis为了屏蔽不同系统库的差异进行了如下预处理：</p>
<ul>
<li>若系统中存在google的tcalloc库，则使用tc_malloc一族函数代替原本的malloc一族函数</li>
<li>若系统中存在facebook的jemalloc库，则使用je_malloc一族函数代替原本的malloc一族函数 </li>
<li>若当前系统是Mac系统，则使用<malloc malloc.h="">中的内存分配函数</malloc></li>
<li>其他情况，在每一段分配好的空间头，同时多分配一个PREFIX_SIZE长度的字段，用来记录分配的空间大小 </li>
</ul>
<p>tcalloc库的tc_malloc_size函数，jemalloc库的je_malloc_usable_size， Mac系统的malloc_size函数提供了计算分配的空间大小的函数，因此无需单独分配空间记录分配的空间大小，根据HAVE_MALLOC_SIZE这个宏来区分。</p>
<h2 id="内存管理函数声明"><a href="#内存管理函数声明" class="headerlink" title="内存管理函数声明"></a>内存管理函数声明</h2><p>redis内存管理的相关函数主要声明在src/zmalloc.h文件中，主要实现了内存的分配、释放、异常处理和内存统计功能。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void *zmalloc(size_t size); //调用zmalloc函数，申请size大小的空间</div><div class="line">void *zcalloc(size_t size); //调用系统函数calloc申请内存空间</div><div class="line">void *zrealloc(void *ptr, size_t size); //原内存重新调整为size空间的大小</div><div class="line">void zfree(void *ptr); //调用zfree函数释放内存空间</div><div class="line">char *zstrdup(const char *s); //字符串复制方法</div><div class="line">size_t zmalloc_used_memory(void); //获取当前以及占用的内存空间大小</div><div class="line">void zmalloc_set_oom_handler(void (*oom_handler)(size_t)); //自定义设置内存溢出的处理方法</div><div class="line">float zmalloc_get_fragmentation_ratio(size_t rss); //获取所给内存和已使用内存的大小之比   </div><div class="line">size_t zmalloc_get_rss(void); //获取RSS信息(Resident Set Size)</div><div class="line">size_t zmalloc_get_private_dirty(long pid); //获得实际内存大小</div><div class="line">size_t zmalloc_get_smap_bytes_by_field(char *field, long pid); //获取/proc/self/smaps字段的字节数</div><div class="line">size_t zmalloc_get_memory_size(void); //获取物理内存大小</div><div class="line">void zlibc_free(void *ptr); //原始系统free释放方法</div></pre></td></tr></table></figure>
<p>同时，关注以下几个变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> used_memory = <span class="number">0</span>; <span class="comment">//已使用内存的大小，每当分配或释放内存时都会对其进行更新</span></div><div class="line"><span class="keyword">pthread_mutex_t</span> used_memory_mutex = PTHREAD_MUTEX_INITIALIZER; <span class="comment">//定义并初始化一个互斥量,用于对used_memory的互斥操作</span></div></pre></td></tr></table></figure>
<h2 id="内存管理函数实现"><a href="#内存管理函数实现" class="headerlink" title="内存管理函数实现"></a>内存管理函数实现</h2><h3 id="内存统计功能"><a href="#内存统计功能" class="headerlink" title="内存统计功能"></a>内存统计功能</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用互斥锁增加已使用的内存大小，然后将内存的大小记录到全局变量used_memory中</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_alloc(__n) do &#123; \</span></div><div class="line">    size_t _n = (__n); \</div><div class="line">    <span class="comment">//精确维护used_memory的值，因为malloc函数分配内存时会考虑内存对齐</span></div><div class="line">    <span class="comment">//如程序请求1个byte，通常malloc分配4个byte进行内存对齐，所以这里used_memory的值并不是程序请求内存大小</span></div><div class="line">    <span class="keyword">if</span> (_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) _n += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)); \</div><div class="line">    atomicIncr(used_memory,__n); \</div><div class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</div><div class="line"><span class="comment">//使用互斥锁减少已使用的内存大小，然后将内存的大小记录到全局变量used_memory中</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_free(__n) do &#123; \</span></div><div class="line">    size_t _n = (__n); \</div><div class="line">    <span class="comment">//精确维护used_memory的值，因为malloc函数分配内存时会考虑内存对齐</span></div><div class="line">    <span class="comment">//如程序请求1个byte，通常malloc分配4个byte进行内存对齐，所以这里used_memory的值并不是程序请求内存大小</span></div><div class="line">    <span class="keyword">if</span> (_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) _n += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)); \</div><div class="line">    atomicDecr(used_memory,__n); \</div><div class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> used_memory = <span class="number">0</span>; <span class="comment">//已使用内存的大小，每当分配或释放内存时都会对其进行更新</span></div><div class="line"><span class="keyword">pthread_mutex_t</span> used_memory_mutex = PTHREAD_MUTEX_INITIALIZER; <span class="comment">//定义并初始化一个互斥量,用于对used_memory的互斥操作</span></div></pre></td></tr></table></figure>
<p>atomicIncr和atomicDecr是两个宏定义，在src/atomicvar.h中，使用互斥锁更新使用的内存的宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> atomicIncr(var,count) do &#123; \</span></div><div class="line">    <span class="comment">//加互斥锁</span></div><div class="line">    pthread_mutex_lock(&amp;var ## _mutex); \</div><div class="line">    var += (count); \</div><div class="line">    <span class="comment">//释放互斥锁</span></div><div class="line">    pthread_mutex_unlock(&amp;var ## _mutex); \</div><div class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> atomicDecr(var,count) do &#123; \</span></div><div class="line">    pthread_mutex_lock(&amp;var ## _mutex); \</div><div class="line">    var -= (count); \</div><div class="line">    pthread_mutex_unlock(&amp;var ## _mutex); \</div><div class="line">&#125; while(0)</div></pre></td></tr></table></figure>
<h3 id="内存申请函数zmalloc"><a href="#内存申请函数zmalloc" class="headerlink" title="内存申请函数zmalloc"></a>内存申请函数zmalloc</h3><p>zmalloc函数调用了系统的malloc函数，对内存分配异常做了处理，统计内存的使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zmalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">    <span class="comment">//调用malloc分配了size+PREFIX_SIZE个字节</span></div><div class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size+PREFIX_SIZE);</div><div class="line">    <span class="comment">//如果ptr为NULL，则调用异常处理函数</span></div><div class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size);</div><div class="line"><span class="comment">//使用tcmalloc，jemalloc或者当前系统是Mac系统，无须记录分配的内存大小</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</div><div class="line">    <span class="keyword">return</span> ptr;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    <span class="comment">//否则PREFIX_SIZE大小的内存用于记录该段内存的大小</span></div><div class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</div><div class="line">    <span class="comment">//更新使用内存的大小</span></div><div class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里注意返回的指针(char*)ptr+PREFIX_SIZE，并不是记录分配的内存大小的内存地址。zmalloc与malloc分配内存的关系如下图：<br><img src="/img/redis/memory-management/1.png" alt="redis source code overview"> </p>
<p>默认的异常处理函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zmalloc_default_oom</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"zmalloc: Out of memory trying to allocate %zu bytes\n"</span>,</div><div class="line">        size);<span class="comment">//打印内存不足的输出日志</span></div><div class="line">    fflush(<span class="built_in">stderr</span>);</div><div class="line">    <span class="built_in">abort</span>(); <span class="comment">//中断</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>更新内存使用量的是update_zmalloc_stat_alloc，在内存统计功能已经说明。</p>
<h3 id="内存申请函数zcalloc"><a href="#内存申请函数zcalloc" class="headerlink" title="内存申请函数zcalloc"></a>内存申请函数zcalloc</h3><p>zcalloc函数也是调用了系统的malloc函数，对内存分配异常做了处理，统计内存的使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zcalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">    <span class="comment">//调用系统函数calloc()来申请内存</span></div><div class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">calloc</span>(<span class="number">1</span>, size+PREFIX_SIZE);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size);</div><div class="line"><span class="comment">//使用tcmalloc，jemalloc或者当前系统是Mac系统，无须记录分配的内存大小</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</div><div class="line">    <span class="keyword">return</span> ptr;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</div><div class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="内存更改函数zrealloc"><a href="#内存更改函数zrealloc" class="headerlink" title="内存更改函数zrealloc"></a>内存更改函数zrealloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zrealloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    <span class="keyword">void</span> *realptr;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">size_t</span> oldsize;</div><div class="line">    <span class="keyword">void</span> *newptr;</div><div class="line">    <span class="comment">//如果ptr为NULL，直接调用zmalloc分配内存</span></div><div class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span> zmalloc(size);</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    oldsize = zmalloc_size(ptr);</div><div class="line">    newptr = <span class="built_in">realloc</span>(ptr,size);</div><div class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom_handler(size);</div><div class="line"></div><div class="line">    update_zmalloc_stat_free(oldsize);</div><div class="line">    update_zmalloc_stat_alloc(zmalloc_size(newptr));</div><div class="line">    <span class="keyword">return</span> newptr;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    <span class="comment">//找到内存真正的起始位置</span></div><div class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</div><div class="line">    <span class="comment">//原来使用的内存大小</span></div><div class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr);</div><div class="line">    newptr = <span class="built_in">realloc</span>(realptr,size+PREFIX_SIZE);</div><div class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom_handler(size);</div><div class="line">    <span class="comment">//把新分配的内存大小记录到新分配内存的头部</span></div><div class="line">    *((<span class="keyword">size_t</span>*)newptr) = size;</div><div class="line">    <span class="comment">//更新used_memory的值，先减去原来使用的内存大小，再增加调整后的大小</span></div><div class="line">    update_zmalloc_stat_free(oldsize);</div><div class="line">    update_zmalloc_stat_alloc(size);</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)newptr+PREFIX_SIZE;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="内存释放函数zfree"><a href="#内存释放函数zfree" class="headerlink" title="内存释放函数zfree"></a>内存释放函数zfree</h3><p>zfree函数通过调用系统的free函数释放内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zfree</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    <span class="keyword">void</span> *realptr;</div><div class="line">    <span class="keyword">size_t</span> oldsize;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="comment">// ptr为空，直接返回</span></div><div class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE <span class="comment">//tcalloc库,jemalloc库或Mac系统时，使用zmalloc_size获取分配的空间</span></span></div><div class="line">    update_zmalloc_stat_free(zmalloc_size(ptr));</div><div class="line">    <span class="built_in">free</span>(ptr);</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"></div><div class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE; <span class="comment">//内存真正的起始地址</span></div><div class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr); <span class="comment">//获取长度</span></div><div class="line">    update_zmalloc_stat_free(oldsize+PREFIX_SIZE); <span class="comment">//更新内存使用量</span></div><div class="line">    <span class="built_in">free</span>(realptr); <span class="comment">//释放内存</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="字符串复制函数zstrdup"><a href="#字符串复制函数zstrdup" class="headerlink" title="字符串复制函数zstrdup"></a>字符串复制函数zstrdup</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">zstrdup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>&#123;</div><div class="line">    <span class="keyword">size_t</span> l = <span class="built_in">strlen</span>(s)+<span class="number">1</span>;</div><div class="line">    <span class="keyword">char</span> *p = zmalloc(l);</div><div class="line"></div><div class="line">    <span class="built_in">memcpy</span>(p,s,l);</div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="获取内存使用量函数zmalloc-used-memory"><a href="#获取内存使用量函数zmalloc-used-memory" class="headerlink" title="获取内存使用量函数zmalloc_used_memory"></a>获取内存使用量函数zmalloc_used_memory</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">size_t</span> zmalloc_used_memory(<span class="keyword">void</span>) &#123;</div><div class="line">    <span class="keyword">size_t</span> um;</div><div class="line">    atomicGet(used_memory,um);</div><div class="line">    <span class="keyword">return</span> um;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，使用互斥锁更新使用的内存的atomicGet宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> atomicGet(var,dstvar) do &#123; \</span></div><div class="line">    pthread_mutex_lock(&amp;var ## _mutex); \</div><div class="line">    dstvar = var; \</div><div class="line">    pthread_mutex_unlock(&amp;var ## _mutex); \</div><div class="line">&#125; while(0)</div></pre></td></tr></table></figure>
<h3 id="获取进程的RSS函数zmalloc-get-rss"><a href="#获取进程的RSS函数zmalloc-get-rss" class="headerlink" title="获取进程的RSS函数zmalloc_get_rss"></a>获取进程的RSS函数zmalloc_get_rss</h3><p>rss全称<a href="https://en.wikipedia.org/wiki/Resident_set_size" target="_blank" rel="external">Resident Set Size</a>，指实际使用物理内存。<br>linux系统获取RSS的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">size_t</span> zmalloc_get_rss(<span class="keyword">void</span>) &#123;</div><div class="line">    <span class="comment">//获得当前系统的内存页大小</span></div><div class="line">    <span class="keyword">int</span> page = sysconf(_SC_PAGESIZE);</div><div class="line">    <span class="keyword">size_t</span> rss;</div><div class="line">    <span class="keyword">char</span> buf[<span class="number">4096</span>];</div><div class="line">    <span class="keyword">char</span> filename[<span class="number">256</span>];</div><div class="line">    <span class="keyword">int</span> fd, count;</div><div class="line">    <span class="keyword">char</span> *p, *x;</div><div class="line"></div><div class="line">    <span class="comment">//通过proc/pid/stat文件获取内存页数</span></div><div class="line">    <span class="built_in">snprintf</span>(filename,<span class="number">256</span>,<span class="string">"/proc/%d/stat"</span>,getpid());</div><div class="line">    <span class="keyword">if</span> ((fd = open(filename,O_RDONLY)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (read(fd,buf,<span class="number">4096</span>) &lt;= <span class="number">0</span>) &#123;</div><div class="line">        close(fd);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    close(fd);</div><div class="line">    <span class="comment">//RSS在proc/pid/stat文件的第24个域中</span></div><div class="line">    p = buf;</div><div class="line">    count = <span class="number">23</span>; <span class="comment">/* RSS is the 24th field in /proc/&lt;pid&gt;/stat */</span></div><div class="line">    <span class="keyword">while</span>(p &amp;&amp; count--) &#123;</div><div class="line">        p = <span class="built_in">strchr</span>(p,<span class="string">' '</span>);</div><div class="line">        <span class="keyword">if</span> (p) p++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    x = <span class="built_in">strchr</span>(p,<span class="string">' '</span>);</div><div class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    *x = <span class="string">'\0'</span>;</div><div class="line">    <span class="comment">//内存页大小*内存页数，即为RSS</span></div><div class="line">    rss = strtoll(p,<span class="literal">NULL</span>,<span class="number">10</span>);</div><div class="line">    rss *= page;</div><div class="line">    <span class="keyword">return</span> rss;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="获取所给内存和已使用内存的大小之比函数zmalloc-get-fragmentation-ratio"><a href="#获取所给内存和已使用内存的大小之比函数zmalloc-get-fragmentation-ratio" class="headerlink" title="获取所给内存和已使用内存的大小之比函数zmalloc_get_fragmentation_ratio"></a>获取所给内存和已使用内存的大小之比函数zmalloc_get_fragmentation_ratio</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 直接通过rss除以used_memory得到</span></div><div class="line"><span class="comment">/* Fragmentation = RSS / allocated-bytes */</span></div><div class="line"><span class="function"><span class="keyword">float</span> <span class="title">zmalloc_get_fragmentation_ratio</span><span class="params">(<span class="keyword">size_t</span> rss)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">float</span>)rss/zmalloc_used_memory();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;redis使用c语言编写，而c语言没有垃圾回收机制，所有的内存分配和释放都要手动管理。redis在实现中封装c语言的malloc,calloc,realloc和free函数，加上一些异常处理和内存统计功能来对自己的内存进行管理，主要实现在zmalloc.h和zmalloc.c中。
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码剖析--源码结构及阅读方法</title>
    <link href="http://yoursite.com/2018/03/02/redis/redis-read-method/"/>
    <id>http://yoursite.com/2018/03/02/redis/redis-read-method/</id>
    <published>2018-03-01T16:00:00.000Z</published>
    <updated>2018-03-08T14:04:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于工作中用到redis，并且redis的源码相对其他开源软件比较简单，因此先从学习redis源码开始，慢慢累积自己的技术知识。<a id="more"></a></p>
<h2 id="Redis源码获取"><a href="#Redis源码获取" class="headerlink" title="Redis源码获取"></a>Redis源码获取</h2><p>redis源码是开源的，从redis官网下载最新版的stable版本redis 4.0.8，下载地址为<a href="http://download.redis.io/releases/redis-4.0.8.tar.gz" target="_blank" rel="external">http://download.redis.io/releases/redis-4.0.8.tar.gz</a>。执行以下命令：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> ... //进入存放redis的文件夹</div><div class="line">wget http://download.redis.io/releases/redis-4.0.8.tar.gz</div><div class="line">tar -zxvf redis-4.0.8.tar.gz</div></pre></td></tr></table></figure>
<p>解压后进入redis-4.0.8目录下src文件夹，所有的源码如下所示： </p>
<p><img src="/img/redis/overview/1.png" alt="redis source code overview"> </p>
<h2 id="Redis源码解析"><a href="#Redis源码解析" class="headerlink" title="Redis源码解析"></a>Redis源码解析</h2><p>上图src目录下源码文件很多，必须找到一种合理的顺序来阅读各个文件。   </p>
<p>网上找到的源码的阅读法。（摘自<a href="http://redissrc.readthedocs.io/en/latest/index.html" target="_blank" rel="external">redis源码解析</a>)   </p>
<ul>
<li>自底向上：从耦合关系最小的模块开始读，然后逐渐过度到关系紧密的模块。就好像写程序的测试一样，先从单元测试开始，然后才到功能测试。</li>
<li>从功能入手：通过文件名（模块名）和函数名，快速定位到一个功能的具体实现，然后追踪整个实现的运作流程，从而了解该功能的实现方式。   </li>
<li>自顶向下：从程序的main()函数，或者某个特别大的调用者函数为入口，以深度优先或者广度优先的方式阅读它的源码。</li>
</ul>
<p>根据黄健宏老师推荐的阅读顺序（<a href="http://blog.huangz.me/diary/2014/how-to-read-redis-source-code.html" target="_blank" rel="external">如何阅读Redis源码?</a>），可以将redis源代码进行模块的拆分，按阶段由浅入深地阅读学习。   </p>
<h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><p>阅读redis源码的数据结构部分：</p>
<ul>
<li>redis的内存分配 atomicvar.h，zmalloc.h和zmalloc.c</li>
<li>redis的动态字符串实现 sds.h和sds.c</li>
<li>redis的双端链表实现 adlist.h和adlist.c</li>
<li>redis的的字典实现 dict.h和dict.c</li>
<li>redis的跳跃表实现 server.h中的zskiplist结构和zskiplistNode结构，以及t_zset.c中所有以zsl开头的函数，比如zslCreate 、zslInsert 、zslDeleteNode等等</li>
<li>Redis的HyperLogLog实现 hyperloglog.c中的hllhdr结构，及所有以hll开头的函数</li>
</ul>
<h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><p>阅读内存编码数据结构实现：</p>
<ul>
<li>整数集合（intset） intset.h和intset.c</li>
<li>压缩列表（zip list） ziplist.h和ziplist.c</li>
</ul>
<h3 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h3><p>阅读数据类型实现：</p>
<ul>
<li>redis的对象（类型）系统实现 object.c</li>
<li>字符串键的实现 t_string.c</li>
<li>列表键的实现 t_list.c</li>
<li>散列键的实现 t_hash.c</li>
<li>集合键的实现 t_set.c</li>
<li>有序集合键的实现 t_zset.c中除zsl开头的函数之外的所有函数</li>
<li>HyperLogLog键的实现 hyperloglog.c中所有以pf开头的函数</li>
</ul>
<h3 id="第四阶段"><a href="#第四阶段" class="headerlink" title="第四阶段"></a>第四阶段</h3><p>阅读Redis数据库的实现：</p>
<ul>
<li>redis的数据库实现 server.h文件中的redisDb结构，以及db.c文件</li>
<li>redis的数据库通知功能实现 notify.c</li>
<li>redis的RDB持久化实现代码 rdb.c</li>
<li>redis的AOF持久化 aof.c</li>
</ul>
<p>以及一些独立功能模块的实现</p>
<ul>
<li>发布与订阅功能的实现 server.h文件的pubsubPattern结构，以及pubsub.c文件</li>
<li>事务功能的实现 server.h文件的multiState结构以及multiCmd结构，multi.c文件</li>
<li>SORT命令的实现 sort.c</li>
<li>GETBIT 、 SETBIT等二进制位操作命令的实现 bitops.c</li>
</ul>
<h3 id="第五阶段"><a href="#第五阶段" class="headerlink" title="第五阶段"></a>第五阶段</h3><p>阅读客户端和服务器的相关代码：</p>
<ul>
<li>redis的事件处理模块 ae.c/ae_epoll.c/ae_evport.c/ae_kqueue.c/ae_select.c</li>
<li>redis的网路链接库 anet.c和networking.c</li>
<li>redis的服务器端 server.c</li>
<li>redis的客户端 redis-cli.c</li>
</ul>
<p>以及一些独立功能模块的实现</p>
<ul>
<li>lua脚本 scripting.c</li>
<li>慢查询 slowlog.c</li>
<li>监视 monitor.c</li>
</ul>
<h3 id="第六阶段"><a href="#第六阶段" class="headerlink" title="第六阶段"></a>第六阶段</h3><p>阅读Redis多机功能的实现:</p>
<ul>
<li>redis的复制功能 replication.c</li>
<li>redis sentinel sentinel.c</li>
<li>redis的集群 cluster.c</li>
</ul>
<p>整个redis源码按照上述的几个阶段去阅读学习，相信最后一定会有很大的收获！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于工作中用到redis，并且redis的源码相对其他开源软件比较简单，因此先从学习redis源码开始，慢慢累积自己的技术知识。
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>读过的文章</title>
    <link href="http://yoursite.com/2017/07/02/read/tools-read/"/>
    <id>http://yoursite.com/2017/07/02/read/tools-read/</id>
    <published>2017-07-01T16:00:00.000Z</published>
    <updated>2018-03-03T16:25:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p><a href="http://opiece.me/2015/04/09/hexo-guide/" target="_blank" rel="external">使用Hexo搭建个人博客(基于hexo3.0)</a><br><a href="http://opiece.me/2016/03/13/push-hexo-to-github-and-coding/" target="_blank" rel="external">将hexo博客同时托管到github和coding</a><a id="more"></a><br><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">hexo官方文档</a><br><a href="http://theme-next.iissnan.com" target="_blank" rel="external">next主题配置官网</a><br><a href="http://joveyzheng.com/2016/03/03/hexo-theme-next-brief-talk/" target="_blank" rel="external">next主题显示RSS配置</a><br><a href="http://www.maoxuner.cn/2017/03/10/hexo-skip-render.html" target="_blank" rel="external">Hexo渲染时排除部分文件或目录</a><br><a href="http://www.5isjyx.com/coding/201704/nextreadthefulltext.html" target="_blank" rel="external">next主题怎么让首页不显示全文</a><br><a href="https://asdfv1929.github.io/2018/01/28/add-the-end/" target="_blank" rel="external">next主题内给每篇文章后添加结束标语</a><br><a href="https://zhuanlan.zhihu.com/p/28128674" target="_blank" rel="external">hexo的next主题个性化教程:打造炫酷网站</a></p>
<h2 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h2><p><a href="http://blog.leanote.com/post/freewalk/Markdown-语法手册" target="_blank" rel="external">Markdown语法手册</a><br><a href="http://wowubuntu.com/markdown" target="_blank" rel="external">Markdown语法说明</a><br><a href="http://einverne.github.io/markdown-style-guide/zh.html" target="_blank" rel="external">Markdown书写风格指南（中文）</a><br><a href="https://github.com/cirosantilli/markdown-style-guide/blob/gh-pages/index.md" target="_blank" rel="external">Markdown书写风格指南（英文）</a>     </p>
<h2 id="GitBook"><a href="#GitBook" class="headerlink" title="GitBook"></a>GitBook</h2><p><a href="http://gitbook.zhangjikai.com" target="_blank" rel="external">GitBook 使用教程</a><br><a href="https://toolchain.gitbook.com" target="_blank" rel="external">GitBook Toolchain Documentation</a>   </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Hexo&quot;&gt;&lt;a href=&quot;#Hexo&quot; class=&quot;headerlink&quot; title=&quot;Hexo&quot;&gt;&lt;/a&gt;Hexo&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://opiece.me/2015/04/09/hexo-guide/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;使用Hexo搭建个人博客(基于hexo3.0)&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://opiece.me/2016/03/13/push-hexo-to-github-and-coding/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;将hexo博客同时托管到github和coding&lt;/a&gt;
    
    </summary>
    
      <category term="已阅" scheme="http://yoursite.com/categories/%E5%B7%B2%E9%98%85/"/>
    
    
      <category term="收藏" scheme="http://yoursite.com/tags/%E6%94%B6%E8%97%8F/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/06/25/hello-world/"/>
    <id>http://yoursite.com/2017/06/25/hello-world/</id>
    <published>2017-06-24T16:00:00.000Z</published>
    <updated>2018-03-03T16:25:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.<a id="more"></a></p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;.
    
    </summary>
    
      <category term="HelloWorld" scheme="http://yoursite.com/categories/HelloWorld/"/>
    
    
      <category term="HelloWorld" scheme="http://yoursite.com/tags/HelloWorld/"/>
    
  </entry>
  
</feed>
