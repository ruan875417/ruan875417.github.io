<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ryan&#39;s notes</title>
  <subtitle>Fighting</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-12T15:53:38.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ryan Ruan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis源码剖析--简单动态字符串sds</title>
    <link href="http://yoursite.com/2018/03/08/redis/redis-sds/"/>
    <id>http://yoursite.com/2018/03/08/redis/redis-sds/</id>
    <published>2018-03-07T16:00:00.000Z</published>
    <updated>2018-03-12T15:53:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>redis没有使用c语言的字符串标识，而是自己构建了已个简单的动态字符串结构SDS，主要实现在sds.h和sds.c中。<a id="more"></a></p>
<h2 id="SDS定义"><a href="#SDS定义" class="headerlink" title="SDS定义"></a>SDS定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</div></pre></td></tr></table></figure>
<p>从上面的定义看，sds就是char*。与c语言一样，redis也是分配连续的一段内存来保存字符串，但与c语言字符串不同的是，redis的字符串是二进制安全的，它可以存储任意二进制数据，所以它不能以’\0’来标识字符串的结束，因此必定存在一个长度字段已获取整个字符串。长度字段见header定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></div><div class="line"> * However is here to document the layout of type 5 SDS strings. */</div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">// flags共8位，低三位保存类型标志，高5位保存字符串长度，字符串长度必须小于32(2^5-1)</span></div><div class="line">    <span class="keyword">char</span> buf[]; <span class="comment">// 保存具体的字符串</span></div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></div><div class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">// 字符串长度，不包含最后的空终止字符</span></div><div class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">// 字符串的最大容量，不包含header和最后的空终止字符</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">// 低三位保存类型标志</span></div><div class="line">    <span class="keyword">char</span> buf[]; <span class="comment">// 保存具体的字符串</span></div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></div><div class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">/* used */</span></div><div class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></div><div class="line">    <span class="keyword">char</span> buf[];</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></div><div class="line">    <span class="keyword">uint32_t</span> len; <span class="comment">/* used */</span></div><div class="line">    <span class="keyword">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></div><div class="line">    <span class="keyword">char</span> buf[];</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></div><div class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* used */</span></div><div class="line">    <span class="keyword">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></div><div class="line">    <span class="keyword">char</span> buf[];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>sds使用了5种header定义以节省内存，而sdshdr5永远不会被使用，其他4种header都有以下4个字段：</p>
<ul>
<li>len：字符串长度，不包含最后的空终止字符</li>
<li>alloc：字符串的最大容量，不包含header和最后的空终止字符</li>
<li>flags：header的类型</li>
<li>buf：保存具体的字符串</li>
</ul>
<p>5种header的flags取值如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_5  0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_8  1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_16 2</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_32 3</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_64 4</span></div></pre></td></tr></table></figure>
<p>这里需要注意的是<strong>attribute</strong> ((<strong><strong>packed</strong></strong>))，它的作用是告诉编译器取消结构在编译过程中的内存对齐,按照实际占用字节数进行分配。如果没有<strong>attribute</strong> ((<strong>packed</strong>)，就不能保证sds的header部分和数据部分是紧紧相邻的，不能按照固定偏移量获取flags字段。因此，redis的sds字符串的内存布局如下：</p>
<p><img src="/img/redis/sds/1.png" alt="sds memory layout"> </p>
<p>sds定义了以下几个宏来操作header：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_MASK 7 <span class="comment">// 类型掩码</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_BITS 3</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T))); <span class="comment">// 获取header头指针</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T)))) <span class="comment">// 获取header头指针</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_5_LEN(f) ((f)&gt;&gt;SDS_TYPE_BITS) <span class="comment">// 获取sdshdr5的len值</span></span></div></pre></td></tr></table></figure>
<p>这里要注意的是sdshdr##T表示将sdshdr和T连接成一个，如T为8，sdshdr##T即为sdshdr8。SDS_HDR_VAR(T,s)宏定义和SDS_HDR(T,s)宏定义都是获取sds的头指针，SDS_HDR_VAR(T,s)宏定义将获取的头指针保存在sh中。获取头指针后，就很容易获取len属性和alloc属性了。</p>
<p>弄清楚sds的数据结构后，就可以看一下sds的基本操作函数了。</p>
<h2 id="SDS基本操作函数"><a href="#SDS基本操作函数" class="headerlink" title="SDS基本操作函数"></a>SDS基本操作函数</h2><p>《Redis设计与实现》一书中讲到，SDS字符串与C字符串相比，有如下区别：</p>
<ul>
<li>常数复杂度获取字符串长度</li>
<li>杜绝缓冲区溢出</li>
<li>减少修改字符串时带来的内存重分配次数</li>
<li>二进制安全</li>
<li>兼容部分C字符串函数</li>
</ul>
<p>下面一一分析：</p>
<h3 id="常数复杂度获取字符串长度函数sdslen"><a href="#常数复杂度获取字符串长度函数sdslen" class="headerlink" title="常数复杂度获取字符串长度函数sdslen"></a>常数复杂度获取字符串长度函数sdslen</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> size_t <span class="title">sdslen</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</div><div class="line">    <span class="comment">// 获取flags字段的值</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags = s[<span class="number">-1</span>];</div><div class="line">    <span class="comment">// 获取flags字段的第三位，即保存的header类型，根据不同的类型找到头指针后获取len属性</span></div><div class="line">    <span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;</div><div class="line">        <span class="keyword">case</span> SDS_TYPE_5:</div><div class="line">            <span class="keyword">return</span> SDS_TYPE_5_LEN(flags);</div><div class="line">        <span class="keyword">case</span> SDS_TYPE_8:</div><div class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">8</span>,s)-&gt;len;</div><div class="line">        <span class="keyword">case</span> SDS_TYPE_16:</div><div class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">16</span>,s)-&gt;len;</div><div class="line">        <span class="keyword">case</span> SDS_TYPE_32:</div><div class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">32</span>,s)-&gt;len;</div><div class="line">        <span class="keyword">case</span> SDS_TYPE_64:</div><div class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">64</span>,s)-&gt;len;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面可以看出，除了sdshdr5之外，其他都是通过SDS_HDR宏获取sds结构，然后返回结构体的len属性，因此是常数复杂度获取字符串长度。</p>
<h3 id="动态调整函数sdsMakeRoomFor"><a href="#动态调整函数sdsMakeRoomFor" class="headerlink" title="动态调整函数sdsMakeRoomFor"></a>动态调整函数sdsMakeRoomFor</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</div><div class="line">    <span class="keyword">void</span> *sh, *newsh;</div><div class="line">    <span class="comment">// 获取sds剩余空间</span></div><div class="line">    <span class="keyword">size_t</span> avail = sdsavail(s);</div><div class="line">    <span class="keyword">size_t</span> len, newlen;</div><div class="line">    <span class="keyword">char</span> type, oldtype = s[<span class="number">-1</span>] &amp; SDS_TYPE_MASK;<span class="comment">//旧的类型</span></div><div class="line">    <span class="keyword">int</span> hdrlen;</div><div class="line"></div><div class="line">    <span class="comment">// 如果剩余空间足够，直接返回</span></div><div class="line">    <span class="keyword">if</span> (avail &gt;= addlen) <span class="keyword">return</span> s;</div><div class="line">    <span class="comment">// 获取sds长度</span></div><div class="line">    len = sdslen(s);</div><div class="line">    sh = (<span class="keyword">char</span>*)s-sdsHdrSize(oldtype);</div><div class="line">    newlen = (len+addlen);</div><div class="line">    <span class="comment">// 空间预分配：</span></div><div class="line">    <span class="comment">// 扩展后的SDS字符串长度newlen小于1MB，分配和newlen同样大小的未使用空间</span></div><div class="line">    <span class="comment">// 否则，分配1MB大小的未使用空间</span></div><div class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC) </div><div class="line">        newlen *= <span class="number">2</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        newlen += SDS_MAX_PREALLOC;</div><div class="line">    <span class="comment">// 根据扩展后的字符串长度，获取header类型</span></div><div class="line">    type = sdsReqType(newlen);</div><div class="line"></div><div class="line">    <span class="comment">// 永远不使用SDS_TYPE_5，按SDS_TYPE_8处理</span></div><div class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5) type = SDS_TYPE_8;</div><div class="line">    <span class="comment">// 根据header类型获取header部分的大小</span></div><div class="line">    hdrlen = sdsHdrSize(type);</div><div class="line">    <span class="keyword">if</span> (oldtype==type) &#123;</div><div class="line">        <span class="comment">// 如果与原类型相同，直接调用realloc函数扩充内存</span></div><div class="line">        newsh = s_realloc(sh, hdrlen+newlen+<span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen; <span class="comment">// 返回buf指针</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 如果类型调整了，header部分的大小就需要调整</span></div><div class="line">        <span class="comment">// 这时就需要移动buf[]部分，所以不能使用realloc</span></div><div class="line">        newsh = s_malloc(hdrlen+newlen+<span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)newsh+hdrlen, s, len+<span class="number">1</span>); <span class="comment">// 先把buf部分拷贝到新分配空间</span></div><div class="line">        s_free(sh); <span class="comment">// 释放原内存</span></div><div class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen; <span class="comment">// 更新s，指向数据部分头部</span></div><div class="line">        s[<span class="number">-1</span>] = type; <span class="comment">// 设置type字段</span></div><div class="line">        sdssetlen(s, len);<span class="comment">// 设置len字段</span></div><div class="line">    &#125;</div><div class="line">    sdssetalloc(s, newlen); <span class="comment">// 设置alloc字段</span></div><div class="line">    <span class="keyword">return</span> s; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面可以看出，减少修改字符串时带来的内存重分配次数的策略是通过空间预分配来完成的。首先如果剩余空间足够，直接返回；否则扩展新空间，扩展后的SDS字符串长度newlen小于1MB，分配和newlen同样大小的未使用空间；否则，分配1MB大小的未使用空间。这样SDS将连续增长N次字符串所需的内存分配次数从必定N次到最多N次。</p>
<h3 id="sdstrim函数"><a href="#sdstrim函数" class="headerlink" title="sdstrim函数"></a>sdstrim函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 从sds字符串左右两端分别移除所有在cset中出现过的字符</span></div><div class="line"><span class="function">sds <span class="title">sdstrim</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *cset)</span> </span>&#123;</div><div class="line">    <span class="keyword">char</span> *start, *end, *sp, *ep;</div><div class="line">    <span class="keyword">size_t</span> len;</div><div class="line"></div><div class="line">    sp = start = s;</div><div class="line">    ep = end = s+sdslen(s)<span class="number">-1</span>;</div><div class="line">    <span class="keyword">while</span>(sp &lt;= end &amp;&amp; <span class="built_in">strchr</span>(cset, *sp)) sp++;</div><div class="line">    <span class="keyword">while</span>(ep &gt; sp &amp;&amp; <span class="built_in">strchr</span>(cset, *ep)) ep--;</div><div class="line">    len = (sp &gt; ep) ? <span class="number">0</span> : ((ep-sp)+<span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (s != sp) memmove(s, sp, len);</div><div class="line">    s[len] = <span class="string">'\0'</span>;</div><div class="line">    <span class="comment">// 设置len字段大小，alloc字段不变</span></div><div class="line">    <span class="comment">// 如果有移除的字符，并没有真正释放内存，那么字符串未使用空间增大</span></div><div class="line">    sdssetlen(s,len); </div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面可以看出，如果sds字符串中有移除的字符，并没有真正释放内存，那么字符串未使用空间增大，这就是惰性空间释放，下次SDS增长字符串所需的内存分配次数从必定分配到最多分配1次。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;redis没有使用c语言的字符串标识，而是自己构建了已个简单的动态字符串结构SDS，主要实现在sds.h和sds.c中。
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码剖析--内存管理</title>
    <link href="http://yoursite.com/2018/03/05/redis/redis-memory-management/"/>
    <id>http://yoursite.com/2018/03/05/redis/redis-memory-management/</id>
    <published>2018-03-04T16:00:00.000Z</published>
    <updated>2018-03-08T14:04:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>redis使用c语言编写，而c语言没有垃圾回收机制，所有的内存分配和释放都要手动管理。redis在实现中封装c语言的malloc,calloc,realloc和free函数，加上一些异常处理和内存统计功能来对自己的内存进行管理，主要实现在zmalloc.h和zmalloc.c中。<a id="more"></a></p>
<h2 id="屏蔽底层平台的差异"><a href="#屏蔽底层平台的差异" class="headerlink" title="屏蔽底层平台的差异"></a>屏蔽底层平台的差异</h2><p>redis对系统的内存分配释放函数进行了一层简单的封装，屏蔽了底层平台的差异，同时方便自己实现相关的函数。src/zmalloc.h文件中的相关宏定义屏蔽了底层平台之间的差异，相关宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//是否使用tcmalloc，如果是，会用tcmalloc对应的函数替换掉标准的libc中的函数实现</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(USE_TCMALLOC)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ZMALLOC_LIB (<span class="meta-string">"tcmalloc-"</span> __xstr(TC_VERSION_MAJOR) <span class="meta-string">"."</span> __xstr(TC_VERSION_MINOR))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;google/tcmalloc.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> (TC_VERSION_MAJOR == 1 &amp;&amp; TC_VERSION_MINOR &gt;= 6) || (TC_VERSION_MAJOR &gt; 1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_MALLOC_SIZE 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> zmalloc_size(p) tc_malloc_size(p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">"Newer version of tcmalloc required"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="comment">//是否使用jemalloc，如果是，会用jemalloc对应的函数替换掉标准的libc中的函数实现</span></div><div class="line"><span class="comment">//jemalloc已经作为源码包的一部分包含在源码包deps/jemalloc目录下，可以直接被使用</span></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(USE_JEMALLOC)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ZMALLOC_LIB (<span class="meta-string">"jemalloc-"</span> __xstr(JEMALLOC_VERSION_MAJOR) <span class="meta-string">"."</span> __xstr(JEMALLOC_VERSION_MINOR) <span class="meta-string">"."</span> __xstr(JEMALLOC_VERSION_BUGFIX))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jemalloc/jemalloc.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> (JEMALLOC_VERSION_MAJOR == 2 &amp;&amp; JEMALLOC_VERSION_MINOR &gt;= 1) || (JEMALLOC_VERSION_MAJOR &gt; 2)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_MALLOC_SIZE 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> zmalloc_size(p) je_malloc_usable_size(p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">"Newer version of jemalloc required"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="comment">//当前系统是否是Mac系统，如果是，则使用&lt;malloc/malloc.h&gt;中的内存分配函数</span></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__APPLE__)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc/malloc.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_MALLOC_SIZE 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> zmalloc_size(p) malloc_size(p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="comment">//最后使用标准的libc中的内存管理函数</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ZMALLOC_LIB</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ZMALLOC_LIB <span class="meta-string">"libc"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFIX_SIZE (0)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__sun) || defined(__sparc) || defined(__sparc__)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFIX_SIZE (sizeof(long long))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFIX_SIZE (sizeof(size_t))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p>从上面的宏预处理，我们可以看出redis为了屏蔽不同系统库的差异进行了如下预处理：</p>
<ul>
<li>若系统中存在google的tcalloc库，则使用tc_malloc一族函数代替原本的malloc一族函数</li>
<li>若系统中存在facebook的jemalloc库，则使用je_malloc一族函数代替原本的malloc一族函数 </li>
<li>若当前系统是Mac系统，则使用<malloc malloc.h="">中的内存分配函数</malloc></li>
<li>其他情况，在每一段分配好的空间头，同时多分配一个PREFIX_SIZE长度的字段，用来记录分配的空间大小 </li>
</ul>
<p>tcalloc库的tc_malloc_size函数，jemalloc库的je_malloc_usable_size， Mac系统的malloc_size函数提供了计算分配的空间大小的函数，因此无需单独分配空间记录分配的空间大小，根据HAVE_MALLOC_SIZE这个宏来区分。</p>
<h2 id="内存管理函数声明"><a href="#内存管理函数声明" class="headerlink" title="内存管理函数声明"></a>内存管理函数声明</h2><p>redis内存管理的相关函数主要声明在src/zmalloc.h文件中，主要实现了内存的分配、释放、异常处理和内存统计功能。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void *zmalloc(size_t size); //调用zmalloc函数，申请size大小的空间</div><div class="line">void *zcalloc(size_t size); //调用系统函数calloc申请内存空间</div><div class="line">void *zrealloc(void *ptr, size_t size); //原内存重新调整为size空间的大小</div><div class="line">void zfree(void *ptr); //调用zfree函数释放内存空间</div><div class="line">char *zstrdup(const char *s); //字符串复制方法</div><div class="line">size_t zmalloc_used_memory(void); //获取当前以及占用的内存空间大小</div><div class="line">void zmalloc_set_oom_handler(void (*oom_handler)(size_t)); //自定义设置内存溢出的处理方法</div><div class="line">float zmalloc_get_fragmentation_ratio(size_t rss); //获取所给内存和已使用内存的大小之比   </div><div class="line">size_t zmalloc_get_rss(void); //获取RSS信息(Resident Set Size)</div><div class="line">size_t zmalloc_get_private_dirty(long pid); //获得实际内存大小</div><div class="line">size_t zmalloc_get_smap_bytes_by_field(char *field, long pid); //获取/proc/self/smaps字段的字节数</div><div class="line">size_t zmalloc_get_memory_size(void); //获取物理内存大小</div><div class="line">void zlibc_free(void *ptr); //原始系统free释放方法</div></pre></td></tr></table></figure>
<p>同时，关注以下几个变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> used_memory = <span class="number">0</span>; <span class="comment">//已使用内存的大小，每当分配或释放内存时都会对其进行更新</span></div><div class="line"><span class="keyword">pthread_mutex_t</span> used_memory_mutex = PTHREAD_MUTEX_INITIALIZER; <span class="comment">//定义并初始化一个互斥量,用于对used_memory的互斥操作</span></div></pre></td></tr></table></figure>
<h2 id="内存管理函数实现"><a href="#内存管理函数实现" class="headerlink" title="内存管理函数实现"></a>内存管理函数实现</h2><h3 id="内存统计功能"><a href="#内存统计功能" class="headerlink" title="内存统计功能"></a>内存统计功能</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用互斥锁增加已使用的内存大小，然后将内存的大小记录到全局变量used_memory中</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_alloc(__n) do &#123; \</span></div><div class="line">    size_t _n = (__n); \</div><div class="line">    <span class="comment">//精确维护used_memory的值，因为malloc函数分配内存时会考虑内存对齐</span></div><div class="line">    <span class="comment">//如程序请求1个byte，通常malloc分配4个byte进行内存对齐，所以这里used_memory的值并不是程序请求内存大小</span></div><div class="line">    <span class="keyword">if</span> (_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) _n += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)); \</div><div class="line">    atomicIncr(used_memory,__n); \</div><div class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</div><div class="line"><span class="comment">//使用互斥锁减少已使用的内存大小，然后将内存的大小记录到全局变量used_memory中</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_free(__n) do &#123; \</span></div><div class="line">    size_t _n = (__n); \</div><div class="line">    <span class="comment">//精确维护used_memory的值，因为malloc函数分配内存时会考虑内存对齐</span></div><div class="line">    <span class="comment">//如程序请求1个byte，通常malloc分配4个byte进行内存对齐，所以这里used_memory的值并不是程序请求内存大小</span></div><div class="line">    <span class="keyword">if</span> (_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) _n += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)); \</div><div class="line">    atomicDecr(used_memory,__n); \</div><div class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> used_memory = <span class="number">0</span>; <span class="comment">//已使用内存的大小，每当分配或释放内存时都会对其进行更新</span></div><div class="line"><span class="keyword">pthread_mutex_t</span> used_memory_mutex = PTHREAD_MUTEX_INITIALIZER; <span class="comment">//定义并初始化一个互斥量,用于对used_memory的互斥操作</span></div></pre></td></tr></table></figure>
<p>atomicIncr和atomicDecr是两个宏定义，在src/atomicvar.h中，使用互斥锁更新使用的内存的宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> atomicIncr(var,count) do &#123; \</span></div><div class="line">    <span class="comment">//加互斥锁</span></div><div class="line">    pthread_mutex_lock(&amp;var ## _mutex); \</div><div class="line">    var += (count); \</div><div class="line">    <span class="comment">//释放互斥锁</span></div><div class="line">    pthread_mutex_unlock(&amp;var ## _mutex); \</div><div class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> atomicDecr(var,count) do &#123; \</span></div><div class="line">    pthread_mutex_lock(&amp;var ## _mutex); \</div><div class="line">    var -= (count); \</div><div class="line">    pthread_mutex_unlock(&amp;var ## _mutex); \</div><div class="line">&#125; while(0)</div></pre></td></tr></table></figure>
<h3 id="内存申请函数zmalloc"><a href="#内存申请函数zmalloc" class="headerlink" title="内存申请函数zmalloc"></a>内存申请函数zmalloc</h3><p>zmalloc函数调用了系统的malloc函数，对内存分配异常做了处理，统计内存的使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zmalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">    <span class="comment">//调用malloc分配了size+PREFIX_SIZE个字节</span></div><div class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size+PREFIX_SIZE);</div><div class="line">    <span class="comment">//如果ptr为NULL，则调用异常处理函数</span></div><div class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size);</div><div class="line"><span class="comment">//使用tcmalloc，jemalloc或者当前系统是Mac系统，无须记录分配的内存大小</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</div><div class="line">    <span class="keyword">return</span> ptr;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    <span class="comment">//否则PREFIX_SIZE大小的内存用于记录该段内存的大小</span></div><div class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</div><div class="line">    <span class="comment">//更新使用内存的大小</span></div><div class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里注意返回的指针(char*)ptr+PREFIX_SIZE，并不是记录分配的内存大小的内存地址。zmalloc与malloc分配内存的关系如下图：<br><img src="/img/redis/memory-management/1.png" alt="redis source code overview"> </p>
<p>默认的异常处理函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zmalloc_default_oom</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"zmalloc: Out of memory trying to allocate %zu bytes\n"</span>,</div><div class="line">        size);<span class="comment">//打印内存不足的输出日志</span></div><div class="line">    fflush(<span class="built_in">stderr</span>);</div><div class="line">    <span class="built_in">abort</span>(); <span class="comment">//中断</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>更新内存使用量的是update_zmalloc_stat_alloc，在内存统计功能已经说明。</p>
<h3 id="内存申请函数zcalloc"><a href="#内存申请函数zcalloc" class="headerlink" title="内存申请函数zcalloc"></a>内存申请函数zcalloc</h3><p>zcalloc函数也是调用了系统的malloc函数，对内存分配异常做了处理，统计内存的使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zcalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">    <span class="comment">//调用系统函数calloc()来申请内存</span></div><div class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">calloc</span>(<span class="number">1</span>, size+PREFIX_SIZE);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size);</div><div class="line"><span class="comment">//使用tcmalloc，jemalloc或者当前系统是Mac系统，无须记录分配的内存大小</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</div><div class="line">    <span class="keyword">return</span> ptr;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</div><div class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="内存更改函数zrealloc"><a href="#内存更改函数zrealloc" class="headerlink" title="内存更改函数zrealloc"></a>内存更改函数zrealloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zrealloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    <span class="keyword">void</span> *realptr;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">size_t</span> oldsize;</div><div class="line">    <span class="keyword">void</span> *newptr;</div><div class="line">    <span class="comment">//如果ptr为NULL，直接调用zmalloc分配内存</span></div><div class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span> zmalloc(size);</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    oldsize = zmalloc_size(ptr);</div><div class="line">    newptr = <span class="built_in">realloc</span>(ptr,size);</div><div class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom_handler(size);</div><div class="line"></div><div class="line">    update_zmalloc_stat_free(oldsize);</div><div class="line">    update_zmalloc_stat_alloc(zmalloc_size(newptr));</div><div class="line">    <span class="keyword">return</span> newptr;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    <span class="comment">//找到内存真正的起始位置</span></div><div class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</div><div class="line">    <span class="comment">//原来使用的内存大小</span></div><div class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr);</div><div class="line">    newptr = <span class="built_in">realloc</span>(realptr,size+PREFIX_SIZE);</div><div class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom_handler(size);</div><div class="line">    <span class="comment">//把新分配的内存大小记录到新分配内存的头部</span></div><div class="line">    *((<span class="keyword">size_t</span>*)newptr) = size;</div><div class="line">    <span class="comment">//更新used_memory的值，先减去原来使用的内存大小，再增加调整后的大小</span></div><div class="line">    update_zmalloc_stat_free(oldsize);</div><div class="line">    update_zmalloc_stat_alloc(size);</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)newptr+PREFIX_SIZE;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="内存释放函数zfree"><a href="#内存释放函数zfree" class="headerlink" title="内存释放函数zfree"></a>内存释放函数zfree</h3><p>zfree函数通过调用系统的free函数释放内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zfree</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    <span class="keyword">void</span> *realptr;</div><div class="line">    <span class="keyword">size_t</span> oldsize;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="comment">// ptr为空，直接返回</span></div><div class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE <span class="comment">//tcalloc库,jemalloc库或Mac系统时，使用zmalloc_size获取分配的空间</span></span></div><div class="line">    update_zmalloc_stat_free(zmalloc_size(ptr));</div><div class="line">    <span class="built_in">free</span>(ptr);</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"></div><div class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE; <span class="comment">//内存真正的起始地址</span></div><div class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr); <span class="comment">//获取长度</span></div><div class="line">    update_zmalloc_stat_free(oldsize+PREFIX_SIZE); <span class="comment">//更新内存使用量</span></div><div class="line">    <span class="built_in">free</span>(realptr); <span class="comment">//释放内存</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="字符串复制函数zstrdup"><a href="#字符串复制函数zstrdup" class="headerlink" title="字符串复制函数zstrdup"></a>字符串复制函数zstrdup</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">zstrdup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>&#123;</div><div class="line">    <span class="keyword">size_t</span> l = <span class="built_in">strlen</span>(s)+<span class="number">1</span>;</div><div class="line">    <span class="keyword">char</span> *p = zmalloc(l);</div><div class="line"></div><div class="line">    <span class="built_in">memcpy</span>(p,s,l);</div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="获取内存使用量函数zmalloc-used-memory"><a href="#获取内存使用量函数zmalloc-used-memory" class="headerlink" title="获取内存使用量函数zmalloc_used_memory"></a>获取内存使用量函数zmalloc_used_memory</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">size_t</span> zmalloc_used_memory(<span class="keyword">void</span>) &#123;</div><div class="line">    <span class="keyword">size_t</span> um;</div><div class="line">    atomicGet(used_memory,um);</div><div class="line">    <span class="keyword">return</span> um;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，使用互斥锁更新使用的内存的atomicGet宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> atomicGet(var,dstvar) do &#123; \</span></div><div class="line">    pthread_mutex_lock(&amp;var ## _mutex); \</div><div class="line">    dstvar = var; \</div><div class="line">    pthread_mutex_unlock(&amp;var ## _mutex); \</div><div class="line">&#125; while(0)</div></pre></td></tr></table></figure>
<h3 id="获取进程的RSS函数zmalloc-get-rss"><a href="#获取进程的RSS函数zmalloc-get-rss" class="headerlink" title="获取进程的RSS函数zmalloc_get_rss"></a>获取进程的RSS函数zmalloc_get_rss</h3><p>rss全称<a href="https://en.wikipedia.org/wiki/Resident_set_size" target="_blank" rel="external">Resident Set Size</a>，指实际使用物理内存。<br>linux系统获取RSS的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">size_t</span> zmalloc_get_rss(<span class="keyword">void</span>) &#123;</div><div class="line">    <span class="comment">//获得当前系统的内存页大小</span></div><div class="line">    <span class="keyword">int</span> page = sysconf(_SC_PAGESIZE);</div><div class="line">    <span class="keyword">size_t</span> rss;</div><div class="line">    <span class="keyword">char</span> buf[<span class="number">4096</span>];</div><div class="line">    <span class="keyword">char</span> filename[<span class="number">256</span>];</div><div class="line">    <span class="keyword">int</span> fd, count;</div><div class="line">    <span class="keyword">char</span> *p, *x;</div><div class="line"></div><div class="line">    <span class="comment">//通过proc/pid/stat文件获取内存页数</span></div><div class="line">    <span class="built_in">snprintf</span>(filename,<span class="number">256</span>,<span class="string">"/proc/%d/stat"</span>,getpid());</div><div class="line">    <span class="keyword">if</span> ((fd = open(filename,O_RDONLY)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (read(fd,buf,<span class="number">4096</span>) &lt;= <span class="number">0</span>) &#123;</div><div class="line">        close(fd);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    close(fd);</div><div class="line">    <span class="comment">//RSS在proc/pid/stat文件的第24个域中</span></div><div class="line">    p = buf;</div><div class="line">    count = <span class="number">23</span>; <span class="comment">/* RSS is the 24th field in /proc/&lt;pid&gt;/stat */</span></div><div class="line">    <span class="keyword">while</span>(p &amp;&amp; count--) &#123;</div><div class="line">        p = <span class="built_in">strchr</span>(p,<span class="string">' '</span>);</div><div class="line">        <span class="keyword">if</span> (p) p++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    x = <span class="built_in">strchr</span>(p,<span class="string">' '</span>);</div><div class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    *x = <span class="string">'\0'</span>;</div><div class="line">    <span class="comment">//内存页大小*内存页数，即为RSS</span></div><div class="line">    rss = strtoll(p,<span class="literal">NULL</span>,<span class="number">10</span>);</div><div class="line">    rss *= page;</div><div class="line">    <span class="keyword">return</span> rss;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="获取所给内存和已使用内存的大小之比函数zmalloc-get-fragmentation-ratio"><a href="#获取所给内存和已使用内存的大小之比函数zmalloc-get-fragmentation-ratio" class="headerlink" title="获取所给内存和已使用内存的大小之比函数zmalloc_get_fragmentation_ratio"></a>获取所给内存和已使用内存的大小之比函数zmalloc_get_fragmentation_ratio</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 直接通过rss除以used_memory得到</span></div><div class="line"><span class="comment">/* Fragmentation = RSS / allocated-bytes */</span></div><div class="line"><span class="function"><span class="keyword">float</span> <span class="title">zmalloc_get_fragmentation_ratio</span><span class="params">(<span class="keyword">size_t</span> rss)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">float</span>)rss/zmalloc_used_memory();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;redis使用c语言编写，而c语言没有垃圾回收机制，所有的内存分配和释放都要手动管理。redis在实现中封装c语言的malloc,calloc,realloc和free函数，加上一些异常处理和内存统计功能来对自己的内存进行管理，主要实现在zmalloc.h和zmalloc.c中。
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码剖析--源码结构及阅读方法</title>
    <link href="http://yoursite.com/2018/03/02/redis/redis-read-method/"/>
    <id>http://yoursite.com/2018/03/02/redis/redis-read-method/</id>
    <published>2018-03-01T16:00:00.000Z</published>
    <updated>2018-03-08T14:04:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于工作中用到redis，并且redis的源码相对其他开源软件比较简单，因此先从学习redis源码开始，慢慢累积自己的技术知识。<a id="more"></a></p>
<h2 id="Redis源码获取"><a href="#Redis源码获取" class="headerlink" title="Redis源码获取"></a>Redis源码获取</h2><p>redis源码是开源的，从redis官网下载最新版的stable版本redis 4.0.8，下载地址为<a href="http://download.redis.io/releases/redis-4.0.8.tar.gz" target="_blank" rel="external">http://download.redis.io/releases/redis-4.0.8.tar.gz</a>。执行以下命令：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> ... //进入存放redis的文件夹</div><div class="line">wget http://download.redis.io/releases/redis-4.0.8.tar.gz</div><div class="line">tar -zxvf redis-4.0.8.tar.gz</div></pre></td></tr></table></figure>
<p>解压后进入redis-4.0.8目录下src文件夹，所有的源码如下所示： </p>
<p><img src="/img/redis/overview/1.png" alt="redis source code overview"> </p>
<h2 id="Redis源码解析"><a href="#Redis源码解析" class="headerlink" title="Redis源码解析"></a>Redis源码解析</h2><p>上图src目录下源码文件很多，必须找到一种合理的顺序来阅读各个文件。   </p>
<p>网上找到的源码的阅读法。（摘自<a href="http://redissrc.readthedocs.io/en/latest/index.html" target="_blank" rel="external">redis源码解析</a>)   </p>
<ul>
<li>自底向上：从耦合关系最小的模块开始读，然后逐渐过度到关系紧密的模块。就好像写程序的测试一样，先从单元测试开始，然后才到功能测试。</li>
<li>从功能入手：通过文件名（模块名）和函数名，快速定位到一个功能的具体实现，然后追踪整个实现的运作流程，从而了解该功能的实现方式。   </li>
<li>自顶向下：从程序的main()函数，或者某个特别大的调用者函数为入口，以深度优先或者广度优先的方式阅读它的源码。</li>
</ul>
<p>根据黄健宏老师推荐的阅读顺序（<a href="http://blog.huangz.me/diary/2014/how-to-read-redis-source-code.html" target="_blank" rel="external">如何阅读Redis源码?</a>），可以将redis源代码进行模块的拆分，按阶段由浅入深地阅读学习。   </p>
<h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><p>阅读redis源码的数据结构部分：</p>
<ul>
<li>redis的内存分配 atomicvar.h，zmalloc.h和zmalloc.c</li>
<li>redis的动态字符串实现 sds.h和sds.c</li>
<li>redis的双端链表实现 adlist.h和adlist.c</li>
<li>redis的的字典实现 dict.h和dict.c</li>
<li>redis的跳跃表实现 server.h中的zskiplist结构和zskiplistNode结构，以及t_zset.c中所有以zsl开头的函数，比如zslCreate 、zslInsert 、zslDeleteNode等等</li>
<li>Redis的HyperLogLog实现 hyperloglog.c中的hllhdr结构，及所有以hll开头的函数</li>
</ul>
<h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><p>阅读内存编码数据结构实现：</p>
<ul>
<li>整数集合（intset） intset.h和intset.c</li>
<li>压缩列表（zip list） ziplist.h和ziplist.c</li>
</ul>
<h3 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h3><p>阅读数据类型实现：</p>
<ul>
<li>redis的对象（类型）系统实现 object.c</li>
<li>字符串键的实现 t_string.c</li>
<li>列表键的实现 t_list.c</li>
<li>散列键的实现 t_hash.c</li>
<li>集合键的实现 t_set.c</li>
<li>有序集合键的实现 t_zset.c中除zsl开头的函数之外的所有函数</li>
<li>HyperLogLog键的实现 hyperloglog.c中所有以pf开头的函数</li>
</ul>
<h3 id="第四阶段"><a href="#第四阶段" class="headerlink" title="第四阶段"></a>第四阶段</h3><p>阅读Redis数据库的实现：</p>
<ul>
<li>redis的数据库实现 server.h文件中的redisDb结构，以及db.c文件</li>
<li>redis的数据库通知功能实现 notify.c</li>
<li>redis的RDB持久化实现代码 rdb.c</li>
<li>redis的AOF持久化 aof.c</li>
</ul>
<p>以及一些独立功能模块的实现</p>
<ul>
<li>发布与订阅功能的实现 server.h文件的pubsubPattern结构，以及pubsub.c文件</li>
<li>事务功能的实现 server.h文件的multiState结构以及multiCmd结构，multi.c文件</li>
<li>SORT命令的实现 sort.c</li>
<li>GETBIT 、 SETBIT等二进制位操作命令的实现 bitops.c</li>
</ul>
<h3 id="第五阶段"><a href="#第五阶段" class="headerlink" title="第五阶段"></a>第五阶段</h3><p>阅读客户端和服务器的相关代码：</p>
<ul>
<li>redis的事件处理模块 ae.c/ae_epoll.c/ae_evport.c/ae_kqueue.c/ae_select.c</li>
<li>redis的网路链接库 anet.c和networking.c</li>
<li>redis的服务器端 server.c</li>
<li>redis的客户端 redis-cli.c</li>
</ul>
<p>以及一些独立功能模块的实现</p>
<ul>
<li>lua脚本 scripting.c</li>
<li>慢查询 slowlog.c</li>
<li>监视 monitor.c</li>
</ul>
<h3 id="第六阶段"><a href="#第六阶段" class="headerlink" title="第六阶段"></a>第六阶段</h3><p>阅读Redis多机功能的实现:</p>
<ul>
<li>redis的复制功能 replication.c</li>
<li>redis sentinel sentinel.c</li>
<li>redis的集群 cluster.c</li>
</ul>
<p>整个redis源码按照上述的几个阶段去阅读学习，相信最后一定会有很大的收获！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于工作中用到redis，并且redis的源码相对其他开源软件比较简单，因此先从学习redis源码开始，慢慢累积自己的技术知识。
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>读过的文章</title>
    <link href="http://yoursite.com/2017/07/02/read/tools-read/"/>
    <id>http://yoursite.com/2017/07/02/read/tools-read/</id>
    <published>2017-07-01T16:00:00.000Z</published>
    <updated>2018-03-03T16:25:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p><a href="http://opiece.me/2015/04/09/hexo-guide/" target="_blank" rel="external">使用Hexo搭建个人博客(基于hexo3.0)</a><br><a href="http://opiece.me/2016/03/13/push-hexo-to-github-and-coding/" target="_blank" rel="external">将hexo博客同时托管到github和coding</a><a id="more"></a><br><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">hexo官方文档</a><br><a href="http://theme-next.iissnan.com" target="_blank" rel="external">next主题配置官网</a><br><a href="http://joveyzheng.com/2016/03/03/hexo-theme-next-brief-talk/" target="_blank" rel="external">next主题显示RSS配置</a><br><a href="http://www.maoxuner.cn/2017/03/10/hexo-skip-render.html" target="_blank" rel="external">Hexo渲染时排除部分文件或目录</a><br><a href="http://www.5isjyx.com/coding/201704/nextreadthefulltext.html" target="_blank" rel="external">next主题怎么让首页不显示全文</a><br><a href="https://asdfv1929.github.io/2018/01/28/add-the-end/" target="_blank" rel="external">next主题内给每篇文章后添加结束标语</a><br><a href="https://zhuanlan.zhihu.com/p/28128674" target="_blank" rel="external">hexo的next主题个性化教程:打造炫酷网站</a></p>
<h2 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h2><p><a href="http://blog.leanote.com/post/freewalk/Markdown-语法手册" target="_blank" rel="external">Markdown语法手册</a><br><a href="http://wowubuntu.com/markdown" target="_blank" rel="external">Markdown语法说明</a><br><a href="http://einverne.github.io/markdown-style-guide/zh.html" target="_blank" rel="external">Markdown书写风格指南（中文）</a><br><a href="https://github.com/cirosantilli/markdown-style-guide/blob/gh-pages/index.md" target="_blank" rel="external">Markdown书写风格指南（英文）</a>     </p>
<h2 id="GitBook"><a href="#GitBook" class="headerlink" title="GitBook"></a>GitBook</h2><p><a href="http://gitbook.zhangjikai.com" target="_blank" rel="external">GitBook 使用教程</a><br><a href="https://toolchain.gitbook.com" target="_blank" rel="external">GitBook Toolchain Documentation</a>   </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Hexo&quot;&gt;&lt;a href=&quot;#Hexo&quot; class=&quot;headerlink&quot; title=&quot;Hexo&quot;&gt;&lt;/a&gt;Hexo&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://opiece.me/2015/04/09/hexo-guide/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;使用Hexo搭建个人博客(基于hexo3.0)&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://opiece.me/2016/03/13/push-hexo-to-github-and-coding/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;将hexo博客同时托管到github和coding&lt;/a&gt;
    
    </summary>
    
      <category term="已阅" scheme="http://yoursite.com/categories/%E5%B7%B2%E9%98%85/"/>
    
    
      <category term="收藏" scheme="http://yoursite.com/tags/%E6%94%B6%E8%97%8F/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/06/25/hello-world/"/>
    <id>http://yoursite.com/2017/06/25/hello-world/</id>
    <published>2017-06-24T16:00:00.000Z</published>
    <updated>2018-03-03T16:25:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.<a id="more"></a></p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;.
    
    </summary>
    
      <category term="HelloWorld" scheme="http://yoursite.com/categories/HelloWorld/"/>
    
    
      <category term="HelloWorld" scheme="http://yoursite.com/tags/HelloWorld/"/>
    
  </entry>
  
</feed>
